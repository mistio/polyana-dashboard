<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-styles/typography.html">
<link rel="import" href="../timerange-picker/timerange-picker.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="dashboard-row.html">
<link rel="import" href="add-panel.html">

<dom-module id="polyana-dashboard">
    <template>
      <style>
        :host{
          display: block;
        }
        body {
          padding: 20px;
        }
        .list-group-item {
          cursor: move;
          cursor: -webkit-grabbing;
        }
      </style>
      <style is="custom-style">
        paper-card {
          padding: 16px;
          margin: 16px;
        }
    </style>
    <paper-card class="layout horizontal stretch">
        <add-panel uri="[[_computeMetricsUri(dashboard)]]"></add-panel>
        <timerange-picker from="{{from}}" to="{{to}}" on-tap="_handleTap" style="float:right;"></timerange-picker>
    </paper-card>
        <iron-ajax
            id="dataAjax"
            url="/api/v1/dashboards/db"
            handle-as="json"
            method="post"
            debounce-duration="300"></iron-ajax>
        <template is="dom-repeat" items="{{dashboard.rows}}">
            <dashboard-row  class="row" datasources="[[datasources]]" auto-refresh="[[autoRefresh]]" row="{{item}}" style="height: [[item.height]]*2; clear: both; display: block" from="{{from}}" to="{{to}}" id="row-{{index}}" ></dashboard-row>
        </template>
        <iron-ajax
            id='requestAjax'
            auto="[[uri]]"
            url="[[uri]]"
            handle-as="json"
            method="GET"
            on-response="_handleResponse"
            debounce-duration="300">
        </iron-ajax>
    </template>
    <script>
        Polymer({
            is: 'polyana-dashboard',

            properties: {
                dashboardPath: {
                    type: String
                },
                dashboard: {
                    type: Object,
                    observer: '_dashboardUpdated'
                },
                datasources: {
                    type: Array
                },
                meta: {
                    type: Object
                },
                targets: {
                    type: Array,
                    computed: "_getTargets(dashboard, datasources)"
                },
                datapoints: {
                    type: Object
                },
                from: {
                    type: String
                },
                to: {
                    type: String
                },
                autoRefresh: {
                    type: Boolean,
                    value: false
                },
                refreshInterval:{
                  type:Number,
                }
            },
            listeners: {
                'end': '_saveDashboard',
                'resizeDone': '_saveDashboard',
                'graphChanged': '_saveDashboard',
                'refresh':'_autoRefresh',
                'panelAdded':'_panelAdded'
            },

            _handleTap: function() {
                clearRefresh(this);
            },

            _panelAdded:function (e){
              console.log("i got",e.detail);
              var panel ={
                "lines": true,
                "aliasColors": {},
                "datasource": "mist.monitor",
                "id": this.dashboard.rows[0].panels.length,
                "span": 12,
                "stack": false,
                "targets": [{
                    "refId": "A",
                    "target": e.detail
                }],
                "timeFrom": null,
                "timeShift": null,
                "title": e.detail.split(".")[0],
                "type": "graph",
                "machineArray": [[this.dashboard.rows[0].panels[0].machineArray[0][0], this.dashboard.rows[0].panels[0].machineArray[0][1]]],
                "x-axis": true,
                "y-axis": true
              }
              this.push("dashboard.rows.0.panels",panel);
              console.log(this.dashboard);
            },

            _computeMetricsUri: function(dashboard) {
              return "/api/v1/clouds/" + dashboard.rows[0].panels[0].machineArray[0][0] + "/machines/" + dashboard.rows[0].panels[0].machineArray[0][1]+ "/metrics";
            },

            _saveDashboard: function(e) {
                if (this.dashboardPath) {
                    this.$.dataAjax.headers["Content-Type"] = 'application/json';
                    this.$.dataAjax.body = {
                        dashboard: this.dashboard,
                        overwrite: true
                    };
                    this.$.dataAjax.generateRequest();
                } else {
                    // TODO
                }
            },

            _handleResponse: function(data) {
                if (this.dashboard != null && (this.dashboard.id != data.detail.response.dashboard.id)) {
                    clearRefresh(this);
                }
                this.meta = data.detail.response.meta;
                this.dashboard = data.detail.response.dashboard;
            },

            _dashboardUpdated: function(){
                this.from = this.dashboard.time.from;
                this.to = this.dashboard.time.to;
            },

            _getTargets: function(dashboard, datasources) {
                var targets = {}, defaultDatasource;
                for (var i = 0; i < dashboard.rows.length; i++) {
                    if (dashboard.rows[i].panels)
                        for (var j = 0; j < dashboard.rows[i].panels.length; j++)
                            if (dashboard.rows[i].panels[j] && dashboard.rows[i].panels[j].targets)
                                for (var k = 0; k < dashboard.rows[i].panels[j].targets.length; k++) {
                                    if (dashboard.rows[i].panels[j].datasource == null) {
                                        for (var p = 0; p < datasources.length; p++) {
                                            if (datasources[p].isDefault) {
                                                defaultDatasource = datasources[p].name;
                                            }
                                        }
                                    }
                                    if (dashboard.rows[i].panels[j].datasource && targets[dashboard.rows[i].panels[j].datasource] == undefined) {
                                        targets[dashboard.rows[i].panels[j].datasource] = [];
                                    }
                                    if (!dashboard.rows[i].panels[j].datasource && targets[defaultDatasource] == undefined) {
                                        targets[defaultDatasource] = [];
                                    }
                                    var datasource = dashboard.rows[i].panels[j].datasource || defaultDatasource;
                                    if (dashboard.rows[i].panels[j].targets[k].target && targets[datasource].indexOf(dashboard.rows[i].panels[j].targets[k].target) == -1) {
                                        targets[datasource].push(dashboard.rows[i].panels[j].targets[k].target);
                                    }
                                }
                }
                return targets
            },
            _autoRefresh: function(value) {
                this.refreshInterval=value.detail;
                if (this.refreshInterval > 0) {
                    this.from = refreshMe(this);
                } else {
                    clearRefresh(this);
                }
            },
        });

        var interval;
        var undermin = 0;

        function clearRefresh(me) {
            me.autoRefresh = false;
            me.refreshInterval = 0;
            clearTimeout(interval);
            console.log("refresh cleared");
        }

        function refreshMe(me) {
            interval = setTimeout(function() {
                refreshMe(me);
            }, me.refreshInterval);
            //first time you pick autorefresh without having change the date/time previously "from" is in this format (now-xh) and needs to be changed
            if (me.from.toString().search("now") >= 0) {
                var d = Math.floor(new Date().getTime() / 1000);
                if (me.from.indexOf("h") >= 0) {
                    var t = me.from.substr(me.from.indexOf("-") + 1, me.from.indexOf("h") - (me.from.indexOf("-") + 1));
                    me.from = (d - t * 3600).toString();
                }
            }
            //in case he has picked a value -10min to now and autorefresh is off for more than that period
            else if (!me.autoRefresh) {
                console.log("reseting panel", me.from);
                me.to= Math.floor(new Date().getTime() / 1000);
                if(typeof me.from != 'string'){
                  me.from = Math.floor(new Date().getTime() / 1000) - (me.to - me.from);
                }
                me.autoRefresh = true;
            } else {
                //instead of doing the whole request (eg we are displaying -1h and we get 1h worth of data). we should request data from our max autorefresh option
                me.to = Math.floor(new Date().getTime() / 1000);
                me.from = Math.floor(new Date().getTime() / 1000) - 300;
            }
            return me.from;
        };
    </script>
</dom-module>
